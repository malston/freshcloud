#!/usr/bin/env bash
#
# freshctl
# Fresh cloud command line client.

__DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" || exit; pwd)"

die() {
    2>&1 echo "$@"
    exit 1
}

# shellcheck disable=SC1091
source "${__DIR}/../.env_development.sh" || die "Could not find '.env_development.sh' in root directory"
# shellcheck disable=SC1091
source "${__DIR}/../components/kubernetes-support/kubectl-support.sh" || die "Could not find 'kubectl-support.sh' in ${__DIR}/../components/kubernetes-support directory"

function create_secret_kpack() {
  echo "Creating docker-registry secret for ${APP_NAME}-registry-credentials"
  kubectl create secret docker-registry "${APP_NAME}-registry-credentials" \
      --docker-username=admin \
      --docker-password="$PASSWD" \
      --docker-server="https://registry.$DOMAIN" \
      --namespace "${APP_NAME}"
}

function create_service_account_kpack() {
  echo "Creating a service account for kpack-${APP_NAME}-registry-credentials"
  cat <<EOF > "${__DIR}/build/${APP_NAME}/${APP_NAME}-service-account.yml"
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ${APP_NAME}-service-account
  namespace: ${APP_NAME}
secrets:
- name: ${APP_NAME}-registry-credentials
`if [ -n "${DEPLOY_KEY}" ]; then
   echo "- name: ${APP_NAME}-deploy-key"
fi`
imagePullSecrets:
- name: ${APP_NAME}-registry-credentials
EOF

  kubectl apply -f "${__DIR}/build/${APP_NAME}/${APP_NAME}-service-account.yml"
}

function create_builder_kpack() {
  echo "Creating the kpack builder"
  cat <<EOF > "${__DIR}/build/${APP_NAME}/${APP_NAME}-kpack-builder.yml"
apiVersion: kpack.io/v1alpha1
kind: Builder
metadata:
  name: ${APP_NAME}-builder
  namespace: ${APP_NAME}
spec:
  serviceAccount: ${APP_NAME}-service-account
  tag: registry.$DOMAIN/kpack/builder
  stack:
    name: base
    kind: ClusterStack
  store:
    name: default
    kind: ClusterStore
  order:
$(if [ "$BUILDPACK" == 'heroku' ]; then
  echo "  - group:"
  echo "    - id: heroku/java"
  echo "  - group:"
  echo "    - id: heroku/nodejs"
else
  echo "  - group:"
  echo "    - id: paketo-buildpacks/java"
  echo "  - group:"
  echo "    - id: paketo-buildpacks/nodejs"
fi)
EOF

  kubectl apply -f "${__DIR}/build/${APP_NAME}/${APP_NAME}-kpack-builder.yml"
}

function create_app_image_spec() {
  echo "Creating the app image spec"
  cat <<EOF > "${__DIR}/build/${APP_NAME}/${APP_NAME}-image-spec.yml"
apiVersion: kpack.io/v1alpha1
kind: Image
metadata:
  name: ${APP_NAME}-image
  namespace: ${APP_NAME}
spec:
  tag: registry.$DOMAIN/kpack/${APP_NAME}
  serviceAccount: ${APP_NAME}-service-account
  builder:
$(if kubectl get namespace "build-service" > /dev/null 2>&1; then
   echo "   name: default"
   echo "   kind: ClusterBuilder"
else
   echo "   name: ${APP_NAME}-builder"
   echo "   kind: Builder"
fi)
  source:
    git:
      url: ${APP_REPO}
      revision: ${APP_BRANCH}
EOF

  kubectl apply -f "${__DIR}/build/${APP_NAME}/${APP_NAME}-image-spec.yml"
}

function install_role_binding() {
  echo "Creating role and role binding"
  cat <<EOF > "${__DIR}/build/${APP_NAME}/${APP_NAME}-role-binding.yml"
kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  namespace: ${APP_NAME}
  name: ${APP_NAME}-image-role
rules:
- apiGroups: ["kpack.io", "", "networking.k8s.io", "apps"]
  resources: ["images", "builds", "pods", "pods/log", "services", "ingresses", "deployments"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: ${APP_NAME}-image-role-binding
  namespace: ${APP_NAME}
subjects:
- kind: ServiceAccount
  name: ${APP_NAME}-service-account
  apiGroup: ""
roleRef:
  kind: Role
  name: ${APP_NAME}-image-role
  apiGroup: ""
EOF

  kubectl apply -f "${__DIR}/build/${APP_NAME}/${APP_NAME}-role-binding.yml"
}

function write_pipeline_params() {
  echo "Writing pipeline params yaml"
  TOKEN_SECRET=$(kubectl get serviceaccount -n argocd argocd -o jsonpath='{.secrets[0].name}')
  TOKEN=$(kubectl get secret -n argocd "$TOKEN_SECRET" -o jsonpath='{.data.token}' | base64 --decode)
  CLUSTER_NAME=$(kubectl config view -o jsonpath="{.contexts[?(@.name=='"$K8S_CLUSTER_NAME"')].context.cluster}")
  CA=$(kubectl get "secret/${TOKEN_SECRET}" -n argocd -o jsonpath='{.data.ca\.crt}')
  SERVER=$(kubectl config view -o jsonpath="{.clusters[?(@.name=='"$CLUSTER_NAME"')].cluster.server}")

  # Vars we need to add to our kubeconfig
  # SERVER=$(kubectl cluster-info|head -1|awk '{print $NF}')
  # NAME=$(kubectl get secrets -n "${APP_NAME}" |grep "${APP_NAME}-service-account-token"|awk '{print $1}')
  # CA=$(kubectl get "secret/${NAME}" -n "${APP_NAME}" -o jsonpath='{.data.ca\.crt}')
  # TOKEN=$(kubectl get "secret/${NAME}" -n "${APP_NAME}" -o jsonpath='{.data.token}' | base64 --decode)
  # NAMESPACE=$(kubectl get "secret/${NAME}" -n "${APP_NAME}" -o jsonpath='{.data.namespace}' | base64 --decode)

  # Create a role to be used by concourse to deploy application builds.
  cat <<EOF > "${__DIR}/build/${APP_NAME}/${APP_NAME}-params.yml"
service-account-key: random-string
domain: ${DOMAIN}
cluster_server: ${SERVER}
argocd_password: ${PASSWD}
kubeconfig: |
  apiVersion: v1
  kind: Config
  clusters:
  - name: ${CLUSTER_NAME}
    cluster:
      certificate-authority-data: ${CA}
      server: ${SERVER}
  contexts:
  - name: $K8S_CLUSTER_NAME-argocd-token-user@$K8S_CLUSTER_NAME
    context:
      cluster: ${CLUSTER_NAME}
      namespace: default
      user: $K8S_CLUSTER_NAME-argocd-token-user
  current-context: $K8S_CLUSTER_NAME-argocd-token-user@$K8S_CLUSTER_NAME
  users:
  - name: $K8S_CLUSTER_NAME-argocd-token-user
    user:
      token: ${TOKEN}
app_manifest: |
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    labels:
      app: ${APP_NAME}
      source: freshcloud
    name: ${APP_NAME}
    namespace: ${APP_NAME}
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: ${APP_NAME}
    template:
      metadata:
        labels:
          app: ${APP_NAME}
      spec:
        containers:
        - image: CURRENT_APP_IMAGE
          name: ${APP_NAME}
          imagePullPolicy: Always
  ---
  apiVersion: v1
  kind: Service
  metadata:
    labels:
      app: ${APP_NAME}
    name: ${APP_NAME}
    namespace: ${APP_NAME}
  spec:
    ports:
    - port: 80
      protocol: TCP
      targetPort: 8080
    selector:
      app: ${APP_NAME}
    sessionAffinity: None
    type: ClusterIP
  ---
  apiVersion: networking.k8s.io/v1
  kind: Ingress
  metadata:
    name: ${APP_NAME}
    namespace: ${APP_NAME}
    labels:
      app: ${APP_NAME}
    annotations:
      cert-manager.io/cluster-issuer: letsencrypt-prod
      kubernetes.io/ingress.class: contour
      ingress.kubernetes.io/force-ssl-redirect: "true"
      projectcontour.io/websocket-routes: "/"
      kubernetes.io/tls-acme: "true"
  spec:
    rules:
    - host: ${APP_NAME}.${DOMAIN}
      http:
        paths:
        - backend:
            service:
              name: ${APP_NAME}
              port:
                number: 80
          pathType: ImplementationSpecific
    tls:
    - hosts:
      - ${APP_NAME}.${DOMAIN}
      secretName: ${APP_NAME}-cert
EOF

if [ -n "${DEPLOY_KEY}" ]; then
KEY=$(cat "${DEPLOY_KEY}" |awk '{print "  " $0}')
  cat <<EOF >> "${__DIR}/build/${APP_NAME}/${APP_NAME}-params.yml"
git_repo_deploy_key: |
${KEY}
EOF
fi
}

function write_pipeline() {
  echo "Writing pipeline yaml"
  cat <<EOF > "${__DIR}/build/${APP_NAME}/${APP_NAME}-pipeline.yml"
resource_types:
- name: kpack-image
  type: registry-image
  source:
    repository: registry.${DOMAIN}/concourse-images/concourse-kpack-resource
    tag: "1.0"

resources:
  - name: ${APP_NAME}-image
    type: registry-image
    source:
      repository: registry.${DOMAIN}/kpack/${APP_NAME}

  - name: ${APP_NAME}-source-code
    type: git
    source:
      uri: ${APP_REPO}
      branch: ${APP_BRANCH}

EOF
if [ -n "${DEPLOY_KEY}" ]; then
cat <<EOF >> "${__DIR}/build/${APP_NAME}/${APP_NAME}-pipeline.yml"
      private_key: ((git_repo_deploy_key))

EOF
fi

cat <<EOF >> "${__DIR}/build/${APP_NAME}/${APP_NAME}-pipeline.yml"
  - name: ${APP_NAME}-kpack-image
    type: kpack-image
    source:
      image: "${APP_NAME}-image"
      namespace: ${APP_NAME}
      gke:
        json_key: ((service-account-key))
        kubeconfig: ((kubeconfig))

jobs:
  - name: build-${APP_NAME}-image
    plan:
      - get: ${APP_NAME}-source-code
        trigger: true
        #     - task: run unit tests
        # file: source-code/pipeline/unit-test.yml
      - put: ${APP_NAME}-kpack-image
        params:
          commitish: ${APP_NAME}-source-code/.git/ref

  - name: vulnerability-scan
    plan:
    - task: sleep
      config:
        platform: linux
        image_resource:
          type: registry-image
          source:
            repository: registry.${DOMAIN}/kpack/ubuntu
            tag: bionic
        run:
          path: /bin/sleep
          args: [15s]
    - in_parallel:
      - get: ${APP_NAME}-kpack-image
        trigger: true
        passed: [build-${APP_NAME}-image]
      - get: ${APP_NAME}-image
    - task: trivy-fs
      config:
        platform: linux
        image_resource:
          type: registry-image
          source:
            repository: registry.pez.joecool.cc/kpack/aquasec/trivy
            tag: 0.19.2
        inputs:
        - name: ${APP_NAME}-image
        caches:
        - path: trivy-cache
        run:
          path: sh
          args:
          - -cex
          - |
            trivy --cache-dir trivy-cache fs --severity HIGH,CRITICAL --vuln-type library,os --ignore-unfixed --exit-code 1 ${APP_NAME}-image/rootfs

  - name: deploy-${APP_NAME}
    plan:
      - get: ${APP_NAME}-source-code
      - get: ${APP_NAME}-kpack-image
        passed:
        - vulnerability-scan
        trigger: true
      - task: create-app
        config:
          platform: linux
          image_resource:
            type: registry-image
            source:
              repository: registry.${DOMAIN}/concourse-images/kubectl-docker
              tag: latest
          inputs:
            - name: ${APP_NAME}-source-code
          params:
            KUBECONFIG:
            MANIFEST:
            DOMAIN:
            CLUSTER_SERVER:
            ARGOCD_PASSWORD:
          run:
            path: sh
            args:
            - -ec
            - |
              echo "\$KUBECONFIG" > config.yml
              export KUBECONFIG=config.yml
              # Add the config setup with the service account you created
              argocd login argocd.\$DOMAIN --username admin --password \$ARGOCD_PASSWORD
              echo y | argocd cluster add "$K8S_CLUSTER_NAME-argocd-token-user@$K8S_CLUSTER_NAME" --kubeconfig config.yml --server "argocd.\$DOMAIN" --upsert
              # See the clusters added
              argocd cluster list
              if ! kubectl get namespace "${APP_NAME}-development" > /dev/null 2>&1; then
                kubectl create namespace "${APP_NAME}-development"
              fi
              argocd app create "${APP_NAME}-dev" \
                --repo "${APP_DEPLOYMENT_REPO}" \
                --path "argocd/${APP_NAME}/dev" \
                --dest-server "\$CLUSTER_SERVER" \
                --dest-namespace "${APP_NAME}-development" \
                --sync-policy "automated"
              argocd app wait "${APP_NAME}-dev"
              argocd app get "${APP_NAME}-dev"
              printf "\nLogin to the ArgoCD UI at: https://%s\n" "argocd.\$DOMAIN"
          platform: linux
        params:
          KUBECONFIG: ((kubeconfig))
          MANIFEST: ((app_manifest))
          DOMAIN: ((domain))
          CLUSTER_SERVER: ((cluster_server))
          ARGOCD_PASSWORD: ((argocd_password))
EOF
}

function fly_pipeline() {
    echo fly login -c "https://ci.${DOMAIN}" -u admin -p "${PASSWD}" -t "${K8S_CLUSTER_NAME}"
    echo y | fly -t "${K8S_CLUSTER_NAME}" set-pipeline -p "build-${APP_NAME}" \
      -c "${__DIR}/build/${APP_NAME}/${APP_NAME}-pipeline.yml" -l "${__DIR}/build/${APP_NAME}/${APP_NAME}-params.yml"
    fly -t "${K8S_CLUSTER_NAME}" unpause-pipeline -p "build-${APP_NAME}"
}

function add_app() {
  # shellcheck source=apps/${APP_NAME}.sh
  # shellcheck disable=SC1091
  source "${1}"
  echo "Adding ${APP_NAME}"

  mkdir -p "${__DIR}/build/${APP_NAME}"

  echo "Creating kubernetes namespace for ${APP_NAME}"
  create_namespace "${APP_NAME}"

  create_secret_kpack

  if [ -n "${DEPLOY_KEY}" ]; then
    echo "Creating kpack secret for ${APP_NAME}-deploy-key"
    kp secret create "${APP_NAME}-deploy-key" --git-url git@github.com --git-ssh-key "${DEPLOY_KEY}" -n "${APP_NAME}"
  fi

  create_service_account_kpack
  if ! kubectl get namespace "build-service" > /dev/null 2>&1; then
    create_builder_kpack
  fi
  create_app_image_spec
  install_role_binding
  write_pipeline_params
  write_pipeline

  yq e '.app_manifest' "${__DIR}/build/${APP_NAME}/${APP_NAME}-params.yml" > "${__DIR}/build/${APP_NAME}/manifest.yml"

  echo "Deploying the pipeline to Concourse"
  if ! fly_pipeline; then
    fly -t "${K8S_CLUSTER_NAME}" sync > /dev/null 2>&1
    if ! fly_pipeline; then
      echo ""
      echo "Failed to add ${APP_NAME}. Manual cleanup needed."
      exit 1
    fi
  fi

  echo ""
  echo "${APP_NAME} added succesfully!"
  echo "View the build progress with the below command."
  echo "  kp build logs ${APP_NAME}-image -n ${APP_NAME}"
}

function delete_app() {
  if [ ! -e "$1" ]; then
      echo "$1 doesn't seem to exist."
      exit 1
  fi
  # shellcheck source=apps/${APP_NAME}.sh
  # shellcheck disable=SC1091
  source "${1}"


  fly -t "${K8S_CLUSTER_NAME}" dp -p "build-${APP_NAME}"
  echo y | argocd app delete "${APP_NAME}-dev"
  # kubectl delete -f "${__DIR}/build/${APP_NAME}"
  kubectl delete namespace "${APP_NAME}"
  echo "Deleting deployment staging directory: build/${APP_NAME}/"
  rm -rf "${__DIR}/build/${APP_NAME}"
}

function list_apps() {
  for i in $(kubectl get deployments -A -l source=freshcloud | awk '{print $1}' | grep -v NAMESPACE); do
      kubectl get ingress -n "$i" 2> /dev/null|grep -Ev 'NAME|acme-http' | awk '{printf ("%15s\t\t%s\n", $1, $3)}';
  done
}

function list_endpoints() {
  cat << EOF
Harbor: https://registry.${DOMAIN}
user: admin
pass: ${PASSWD}

Concourse: https://ci.${DOMAIN}
user: admin
pass: ${PASSWD}
EOF
}

TERM=dumb

# Options
if [ "$1" == 'endpoints' ]; then
    list_endpoints
elif [ "$1" == 'add' ]; then
  if [ -z "$2" ]; then
    echo "$0 add config.app"
    exit 1
  fi
  [ ! -f "$2" ] && die "Could not find app at: $2"
  add_app "$2"
elif [ "$1" == 'delete' ]; then
  if [ -z "$2" ]; then
    echo "$0 delete config.app"
    exit 1
  fi
  [ ! -f "$2" ] && die "Could not find app at: $2"
  delete_app "$2"
elif [ "$1" == 'apps' ]; then
  list_apps
else
  echo "freshctl manages fresh cloud applications."
  echo ""
  echo "Basic Commands:"
  echo "  $0 add                  add an application"
  echo "  $0 delete               delete an application"
  echo "  $0 endpoints            list endpoints"
  echo "  $0 apps                 list applications"
  echo
  exit 1
fi
